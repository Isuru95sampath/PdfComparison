import streamlit as st
import pdfplumber
import re
import pandas as pd
from io import BytesIO
from fuzzywuzzy import fuzz

def truncate_after_sri_lanka(addr: str) -> str:
    part, sep, _ = addr.partition("Sri Lanka")
    return (part + sep).strip() if sep else addr.strip()

def extract_wo_fields(pdf_file):
    text = "\n".join(page.extract_text() or "" for page in pdfplumber.open(pdf_file).pages)
    customer = delivery = ""
    lines = text.split("\n")
    for i, ln in enumerate(lines):
        if "Deliver To:" in ln:
            customer = lines[i-1].strip() if i > 0 else ""
            delivery = re.sub(r"Deliver To:\s*", "", ln).strip()
            break
    codes = re.findall(r"Product Code[:\s]*([A-Z]+\s*\d+(?:\s*/\s*[A-Z]+\s*\d+)*)", text)
    all_codes = []
    for item in codes:
        parts = [c.strip() for c in item.split("/")]
        all_codes += parts
    return {"customer_name": customer, "delivery_address": delivery, "product_codes": list(set(all_codes))}

def extract_po_fields(pdf_file):
    text = "\n".join(page.extract_text() or "" for page in pdfplumber.open(pdf_file).pages)
    lines = [ln.strip() for ln in text.split("\n")]
    capture = False
    address_lines = []
    for ln in lines:
        if "Delivery Location:" in ln:
            capture = True
            continue
        if capture:
            if "Forwarder:" in ln:
                break
            if ln:
                address_lines.append(ln)
    raw_addr = " ".join(address_lines)
    matches = re.findall(r".*Sri Lanka.*", text, re.IGNORECASE)
    unique = [raw_addr] + [m for m in matches if m != raw_addr]
    seen = []
    for a in unique:
        if a and a not in seen:
            seen.append(a)
    sri = [a for a in seen if "sri lanka" in a.lower()]
    chosen = max(sri, key=len) if sri else seen[0] if seen else raw_addr
    final_addr = truncate_after_sri_lanka(chosen)
    po_codes = re.findall(r"(LB\s*\d+)", text)
    return {"delivery_location": final_addr, "product_codes": po_codes, "all_found_addresses": seen}

def extract_po_details(pdf_file):
    """
    Extract PO details including color codes and sizes from "Colour/Size/Destination:" line
    Color code: read until first space after colon
    Size: extract from between forward slashes
    """
    text = "\n".join(page.extract_text() or "" for page in pdfplumber.open(pdf_file).pages)
    lines = [ln.strip() for ln in text.split("\n") if ln.strip()]
    
    po_items = []
    
    # Find items by looking for item numbers and quantities
    for i, line in enumerate(lines):
        # Look for item rows with pattern: number + item_code + quantity + PCS
        item_match = re.search(r'^(\d+)\s+([A-Z0-9]+)\s+(\d+)\s+(\d+\.\d+)\s+PCS', line)
        
        if item_match:
            item_number = item_match.group(1)
            item_code = item_match.group(2)
            quantity = item_match.group(4)
            
            # Look for the "Colour/Size/Destination:" line in the following lines
            colour_code = ""
            size = ""
            
            for j in range(i + 1, min(i + 15, len(lines))):  # Search next 15 lines
                if "Colour/Size/Destination:" in lines[j]:
                    # Extract the line after "Colour/Size/Destination:"
                    colour_size_line = lines[j].replace("Colour/Size/Destination:", "").strip()
                    
                    # Extract color code (until first space) - should be something like "7EPG"
                    color_match = re.search(r'^(\S+)', colour_size_line)
                    if color_match:
                        colour_code = color_match.group(1)
                    
                    # Extract size (between forward slashes)
                    size_match = re.search(r'/\s*([^/]+)\s*/', colour_size_line)
                    if size_match:
                        size = size_match.group(1).strip()
                    
                    break
                
                # Also check if the line itself contains color code pattern like "7EPG"
                if re.search(r'\b([A-Z0-9]{4})\b', lines[j]):
                    color_code_match = re.search(r'\b([A-Z0-9]{4})\b', lines[j])
                    if color_code_match and not colour_code:
                        colour_code = color_code_match.group(1)
            
            # Extract price if available
            price_match = re.search(r'(\d+\.\d+)$', line)
            price = price_match.group(1) if price_match else ""
            
            po_items.append({
                "Item_Number": item_number,
                "Item_Code": item_code,
                "Quantity": quantity,
                "Colour_Code": colour_code,
                "Size": size,
                "Price": price
            })
    
    return po_items

def process_item_description_updated(item_data, description_lines, raw_line):
    """
    Simplified processing since we're extracting directly from the structured format
    """
    processed_item = {
        "LB_Code": item_data.get("lb_code", ""),
        "Quantity": item_data.get("quantity", ""),
        "Price": item_data.get("price", ""),
        "Colour_Code": item_data.get("colour_code", ""),
        "Size": item_data.get("size", ""),
        "Raw_Line": raw_line
    }
    
    return processed_item

def process_item_description_updated(item_data, description_lines, raw_line):
    """
    Process item description to extract color code and size from 3rd line after "Destination:"
    Color code: read until first space
    Size: extract from (\  \) format
    """
    processed_item = {
        "LB_Code": item_data.get("lb_code", ""),
        "Quantity": item_data.get("quantity", ""),
        "Price": item_data.get("price", ""),
        "Colour_Code": "",
        "Size": "",
        "Raw_Line": raw_line
    }
    
    # Find "Destination:" line and get the 3rd line after it
    destination_found = False
    lines_after_destination = []
    
    for line in description_lines:
        if "Destination:" in line:
            destination_found = True
            continue
        
        if destination_found:
            lines_after_destination.append(line)
    
    # Process the 3rd line after "Destination:"
    if len(lines_after_destination) >= 3:
        third_line = lines_after_destination[2]
        
        # Extract color code - read until first space
        color_match = re.search(r'^(\S+)', third_line.strip())
        if color_match:
            processed_item["Colour_Code"] = color_match.group(1)
        
        # Extract size from (\  \) format
        size_match = re.search(r'\(([^)]+)\)', third_line)
        if size_match:
            processed_item["Size"] = size_match.group(1).strip()
    
    # Extract additional column data from raw line
    if raw_line:
        # Try to extract more structured data
        parts = raw_line.split()
        
        # Look for article numbers, style numbers, etc.
        for part in parts:
            if re.match(r'\d{6,}', part) and not processed_item.get("Article_No"):
                processed_item["Article_No"] = part
            elif re.match(r'[A-Z]{2,3}\d{3,}', part) and not processed_item.get("Style_No"):
                processed_item["Style_No"] = part
    
    return processed_item

def process_item_description(item_data, description_lines, raw_line):
    """
    Process item description to extract color code and size from 3rd line
    """
    processed_item = {
        "LB_Code": item_data.get("lb_code", ""),
        "Quantity": item_data.get("quantity", ""),
        "Price": item_data.get("price", ""),
        "Colour_Code": "",
        "Size": "",
        "Full_Description": " ".join(description_lines),
        "Raw_Line": raw_line
    }
    
    # Method 1: Look for color code and size in 3rd line of description
    if len(description_lines) >= 3:
        third_line = description_lines[2]
        # Pattern: color code followed by / and size (e.g., "7EPG/S")
        color_size_match = re.search(r'([A-Z0-9]+)\s*/\s*([A-Z0-9/]+)', third_line)
        if color_size_match:
            processed_item["Colour_Code"] = color_size_match.group(1)
            processed_item["Size"] = color_size_match.group(2)
    
    # Method 2: Fallback - look in all description lines
    if not processed_item["Colour_Code"]:
        for line in description_lines:
            # Look for patterns like "7EPG", "BK", "WHT", etc.
            color_patterns = [
                r'\b([A-Z]{2,4}[A-Z0-9]*)\s*/\s*([A-Z0-9/]+)',  # Pattern like 7EPG/S
                r'\b([A-Z]{2,4})\s*/\s*([A-Z0-9/]+)',           # Pattern like BK/M
                r'\b([A-Z0-9]{2,6})\s*/\s*([A-Z0-9/]+)'         # General pattern
            ]
            
            for pattern in color_patterns:
                match = re.search(pattern, line)
                if match:
                    processed_item["Colour_Code"] = match.group(1)
                    processed_item["Size"] = match.group(2)
                    break
            
            if processed_item["Colour_Code"]:
                break
    
    # Method 3: Look for color codes without size
    if not processed_item["Colour_Code"]:
        for line in description_lines:
            # Look for standalone color codes
            color_only_patterns = [
                r'\b([A-Z]{4})\b',  # 4-letter codes like 7EPG
                r'\b([A-Z]{2,3})\b'  # 2-3 letter codes like BK, WHT
            ]
            
            for pattern in color_only_patterns:
                matches = re.findall(pattern, line)
                for match in matches:
                    if match not in ['SIZE', 'CODE', 'ITEM', 'DESC', 'STYLE', 'PRICE', 'TOTAL', 'UNIT']:
                        processed_item["Colour_Code"] = match
                        break
                if processed_item["Colour_Code"]:
                    break
    
    # Extract additional column data from raw line
    if raw_line:
        # Try to extract more structured data
        parts = raw_line.split()
        
        # Look for article numbers, style numbers, etc.
        for part in parts:
            if re.match(r'\d{6,}', part) and not processed_item.get("Article_No"):
                processed_item["Article_No"] = part
            elif re.match(r'[A-Z]{2,3}\d{3,}', part) and not processed_item.get("Style_No"):
                processed_item["Style_No"] = part
    
    return processed_item

def extract_color_codes_from_table(text):
    """
    Extract color codes from table structure where 'Colour Code' is a column header.
    This function identifies the table structure and extracts color codes from the appropriate column.
    """
    lines = [line.strip() for line in text.split("\n") if line.strip()]
    color_codes = []
    
    # Find the line containing "Colour Code" header
    colour_header_line_idx = -1
    colour_column_position = -1
    
    for i, line in enumerate(lines):
        if "Colour" in line and "Code" in line:
            colour_header_line_idx = i
            # Find the position of "Colour Code" in the header line
            colour_match = re.search(r'Colour\s*Code', line, re.IGNORECASE)
            if colour_match:
                colour_column_position = colour_match.start()
                break
    
    if colour_header_line_idx == -1:
        return []
    
    # Get the header line to understand column structure
    header_line = lines[colour_header_line_idx]
    
    # Extract color codes from subsequent lines
    for i in range(colour_header_line_idx + 1, len(lines)):
        line = lines[i]
        
        # Stop if we encounter end markers or new sections
        if any(marker in line.lower() for marker in [
            "number of size changes", "end of works order", "page", "version", "http://", "generated"
        ]):
            break
        
        # Skip empty lines or lines that don't contain data
        if not line or len(line.split()) < 2:
            continue
        
        # Method 1: Try to extract based on column position
        if colour_column_position != -1:
            # Look for color code at similar position as header
            try:
                # Split the line and try to get the color code based on position
                parts = line.split()
                if len(parts) >= 3:  # Ensure we have enough parts
                    # Try to find color code based on pattern matching
                    for part in parts:
                        # Look for alphanumeric codes that could be color codes
                        if re.match(r'^[A-Z0-9]+$', part) and len(part) >= 2 and len(part) <= 10:
                            # Additional validation - not pure numbers, not sizes
                            if not part.isdigit() and part not in ['XS', 'XP', 'S', 'M', 'L', 'XL', 'XXL', 'XG', 'XXG']:
                                color_codes.append(part)
                                break
            except:
                pass
        
        # Method 2: Pattern-based extraction for common color code formats
        # Look for patterns like: 7EPG, BK, WHT, etc.
        color_patterns = [
            r'\b([A-Z]{1,2}[A-Z0-9]{1,8})\b',  # Pattern like 7EPG
            r'\b([A-Z]{2,4})\b',                # Pattern like BK, WHT
            r'\b([A-Z0-9\-]{2,8})\b'            # Pattern like BK-001
        ]
        
        for pattern in color_patterns:
            matches = re.findall(pattern, line)
            for match in matches:
                # Filter out common non-color words
                if match not in ['SIZE', 'STYLE', 'PRICE', 'MULTI', 'RETAIL', 'DESC', 'ARTICLE', 'QUANTITY', 'US', 'CA'] and match not in color_codes:
                    color_codes.append(match)
    
    # Method 3: Fallback - look for color codes in the entire document
    if not color_codes:
        # Look for common color code patterns in the entire text
        fallback_patterns = [
            r'\b([A-Z]{4})\b',  # 4-letter codes like 7EPG
            r'\b([A-Z]{2,3})\b' # 2-3 letter codes like BK, WHT
        ]
        
        for pattern in fallback_patterns:
            matches = re.findall(pattern, text)
            for match in matches:
                if (match not in ['SIZE', 'CODE', 'STYLE', 'PRICE', 'MULTI', 'RETAIL', 'DESC', 'ARTICLE', 'QUANTITY', 'DATE', 'DELIVERY', 'ORDER', 'WORKS', 'COPY', 'DETAILS', 'CARE', 'SEASON', 'PRINT', 'COLOR', 'COMBO', 'COLLECTION', 'ENTRY', 'HEADER', 'CONFIRMED', 'CUSTOMER', 'PRINTED', 'RECEIVED', 'FACTORY', 'CONTACT', 'COMMENTS', 'SPECIAL', 'REQUIREMENTS', 'INSTRUCTIONS', 'PRODUCT', 'BRANCH', 'NUMBER', 'ITEM', 'TYPE', 'PAPER', 'DESCRIPTION', 'TICKET', 'UNITS', 'IMAGE', 'LENGTH', 'WIDTH', 'FACTORY', 'BREAKDOWN', 'PANTY', 'CHANGES'] 
                    and len(match) >= 2 
                    and match not in color_codes):
                    color_codes.append(match)
    
    # Remove duplicates while preserving order
    unique_codes = []
    for code in color_codes:
        if code not in unique_codes:
            unique_codes.append(code)
    
    return unique_codes

def extract_wo_items(pdf_file):
    text = "\n".join(page.extract_text() or "" for page in pdfplumber.open(pdf_file).pages)
    lines = [ln.strip() for ln in text.split("\n") if ln.strip()]
    items = []

    # Extract color codes using the new table-based method
    color_codes = extract_color_codes_from_table(text)

    # Method 1: Try to extract from table structure (for your current PDF format)
    table_pattern = (
        r"(\d{8,})\s+"              # Style number (8+ digits)
        r"([A-Z0-9]+)\s+"           # Color code (like 7EPG)
        r"([A-Z]+/[A-Z]+)\s+"       # Size (like XS/XP, S/P, M/M)
        r"\$[\d.]+\s+\$[\d.]+\s+"   # Prices
        r"(\d{13})\s+"              # SKU/UPC
        r"(\d+)\s+"                 # Article number
        r"(\d+)"                    # Quantity
    )
    
    table_matches = re.findall(table_pattern, text)
    
    if table_matches:
        for match in table_matches:
            style, color_code, size, sku, article, quantity = match
            items.append({
                "Style": style,
                "Size 1": size,
                "Quantity": int(quantity),
                "Colour Code": color_code,
                "SKU": sku,
                "Article": article
            })
    else:
        # Method 2: Fallback to original pattern matching
        original_pattern = (
            r"(\d{8,})\s+"              # Style
            r"\S+\s+"                   # Article/Desc
            r"([A-Z]+\/[A-Z]+)\s+"      # Size 1
            r"\$\d+\.\d+\s+\$\d+\.\d+\s+"  # Prices
            r"\d{13}\s+\d+\s+"          # Extra ID
            r"(\d+)"                    # Quantity
        )
        
        matches = re.findall(original_pattern, text)
        for i, match in enumerate(matches):
            style, size, qty = match
            # Assign color codes to items (cycle through if more items than colors)
            color = color_codes[i % len(color_codes)] if color_codes else ""
            
            items.append({
                "Style": style,
                "Size 1": size,
                "Quantity": int(qty),
                "Colour Code": color
            })
    
    return items

def extract_po_quantities(pdf_file):
    text = "\n".join(page.extract_text() or "" for page in pdfplumber.open(pdf_file).pages)
    pattern = r"(\d{1,4}\.\d{3})\s+PCS"
    quantities = re.findall(pattern, text)
    po_qtys = [int(float(qty)) for qty in quantities]
    return po_qtys

def compare_addresses(wo, po):
    ns = fuzz.token_sort_ratio(wo["customer_name"], po["delivery_location"])
    as_ = fuzz.token_sort_ratio(wo["delivery_address"], po["delivery_location"])
    comb = max(ns, as_)
    return {"WO Name": wo["customer_name"], "WO Addr": wo["delivery_address"], "PO Addr": po["delivery_location"],
            "Name %": ns, "Addr %": as_, "Overall %": comb, "Status": "‚úÖ Match" if comb > 85 else "‚ö†Ô∏è Review"}

def compare_codes(wo_codes, po_codes):
    results = []
    for wc in wo_codes:
        found_match = False
        for pc in po_codes:
            pts = fuzz.ratio(wc, pc)
            results.append({"WO Code": wc, "PO Code": pc, "Match %": pts,
                            "Status": "‚úÖ Match" if pts == 100 else "‚ö†Ô∏è Partial" if pts > 80 else "‚ùå No"})
            if pts == 100:
                found_match = True
        if not found_match:
            results.append({"WO Code": wc, "PO Code": "", "Match %": "", "Status": "‚ùå WO code not found in PO"})
    return results

def smart_quantity_matching(wo_items, po_qtys):
    """
    Smart quantity matching logic that tries to find best matches
    between WO quantities and PO quantities instead of just comparing by order.
    """
    matched = []
    mismatched = []
    used_po_indices = set()  # Track which PO quantities have been used
    
    for wo_item in wo_items:
        wo_qty = wo_item["Quantity"]
        found_match = False
        
        # Try to find exact match in PO quantities
        for po_index, po_qty in enumerate(po_qtys):
            if po_index not in used_po_indices and po_qty == wo_qty:
                # Found exact match
                used_po_indices.add(po_index)
                matched.append({
                    "Style": wo_item["Style"],
                    "Size 1": wo_item["Size 1"],
                    "Colour Code": wo_item.get("Colour Code", ""),
                    "WO Qty": wo_qty,
                    "PO Qty": po_qty,
                    "Diff": 0,
                    "Status": "‚úÖ Match",
                    "PO Index": po_index  # Optional: track which PO qty was used
                })
                found_match = True
                break
        
        # If no exact match found, add to mismatched
        if not found_match:
            # Find closest available PO quantity for reference
            closest_po_qty = None
            closest_diff = float('inf')
            closest_po_index = None
            
            for po_index, po_qty in enumerate(po_qtys):
                if po_index not in used_po_indices:
                    diff = abs(po_qty - wo_qty)
                    if diff < closest_diff:
                        closest_diff = diff
                        closest_po_qty = po_qty
                        closest_po_index = po_index
            
            if closest_po_qty is not None:
                used_po_indices.add(closest_po_index)
                mismatched.append({
                    "Style": wo_item["Style"],
                    "Size 1": wo_item["Size 1"],
                    "Colour Code": wo_item.get("Colour Code", ""),
                    "WO Qty": wo_qty,
                    "PO Qty": closest_po_qty,
                    "Diff": closest_po_qty - wo_qty,
                    "Status": "‚ö†Ô∏è Mismatch",
                    "PO Index": closest_po_index
                })
            else:
                # No PO quantity available
                mismatched.append({
                    "Style": wo_item["Style"],
                    "Size 1": wo_item["Size 1"],
                    "Colour Code": wo_item.get("Colour Code", ""),
                    "WO Qty": wo_qty,
                    "PO Qty": None,
                    "Diff": "",
                    "Status": "‚ùå No PO Qty",
                    "PO Index": None
                })
    
    # Handle any unused PO quantities
    unused_po_qtys = []
    for po_index, po_qty in enumerate(po_qtys):
        if po_index not in used_po_indices:
            unused_po_qtys.append({
                "Style": "N/A",
                "Size 1": "N/A",
                "Colour Code": "N/A",
                "WO Qty": None,
                "PO Qty": po_qty,
                "Diff": "",
                "Status": "‚ùå Extra PO Qty",
                "PO Index": po_index
            })
    
    # Add unused PO quantities to mismatched
    mismatched.extend(unused_po_qtys)
    
    return matched, mismatched

def smart_quantity_matching_with_tolerance(wo_items, po_qtys, tolerance=0):
    """
    Smart quantity matching with tolerance for near matches.
    tolerance: acceptable difference between quantities to consider as match
    """
    matched = []
    mismatched = []
    used_po_indices = set()
    
    for wo_item in wo_items:
        wo_qty = wo_item["Quantity"]
        found_match = False
        
        # Try to find exact or near match within tolerance
        for po_index, po_qty in enumerate(po_qtys):
            if po_index not in used_po_indices:
                diff = abs(po_qty - wo_qty)
                if diff <= tolerance:
                    # Found match within tolerance
                    used_po_indices.add(po_index)
                    status = "‚úÖ Match" if diff == 0 else "‚úÖ Near Match"
                    matched.append({
                        "Style": wo_item["Style"],
                        "Size 1": wo_item["Size 1"],
                        "Colour Code": wo_item.get("Colour Code", ""),
                        "WO Qty": wo_qty,
                        "PO Qty": po_qty,
                        "Diff": po_qty - wo_qty,
                        "Status": status,
                        "PO Index": po_index
                    })
                    found_match = True
                    break
        
        # If no match found within tolerance, find closest
        if not found_match:
            closest_po_qty = None
            closest_diff = float('inf')
            closest_po_index = None
            
            for po_index, po_qty in enumerate(po_qtys):
                if po_index not in used_po_indices:
                    diff = abs(po_qty - wo_qty)
                    if diff < closest_diff:
                        closest_diff = diff
                        closest_po_qty = po_qty
                        closest_po_index = po_index
            
            if closest_po_qty is not None:
                used_po_indices.add(closest_po_index)
                mismatched.append({
                    "Style": wo_item["Style"],
                    "Size 1": wo_item["Size 1"],
                    "Colour Code": wo_item.get("Colour Code", ""),
                    "WO Qty": wo_qty,
                    "PO Qty": closest_po_qty,
                    "Diff": closest_po_qty - wo_qty,
                    "Status": "‚ö†Ô∏è Mismatch",
                    "PO Index": closest_po_index
                })
            else:
                mismatched.append({
                    "Style": wo_item["Style"],
                    "Size 1": wo_item["Size 1"],
                    "Colour Code": wo_item.get("Colour Code", ""),
                    "WO Qty": wo_qty,
                    "PO Qty": None,
                    "Diff": "",
                    "Status": "‚ùå No PO Qty",
                    "PO Index": None
                })
    
    # Handle unused PO quantities
    unused_po_qtys = []
    for po_index, po_qty in enumerate(po_qtys):
        if po_index not in used_po_indices:
            unused_po_qtys.append({
                "Style": "N/A",
                "Size 1": "N/A",
                "Colour Code": "N/A",
                "WO Qty": None,
                "PO Qty": po_qty,
                "Diff": "",
                "Status": "‚ùå Extra PO Qty",
                "PO Index": po_index
            })
    
    mismatched.extend(unused_po_qtys)
    
    return matched, mismatched

# Updated function to use smart matching
def compare_quantity_by_order(wo_items, po_qtys):
    """Updated function that uses smart matching logic"""
    return smart_quantity_matching(wo_items, po_qtys)

def make_excel(addr_res, code_res, wo_items, matched, mismatched, po_details=None):
    df_addr = pd.DataFrame([addr_res])
    df_codes = pd.DataFrame(code_res)
    df_items = pd.DataFrame(wo_items)
    df_match = pd.DataFrame(matched)
    df_mismatch = pd.DataFrame(mismatched)
    
    buf = BytesIO()
    with pd.ExcelWriter(buf, engine='openpyxl') as writer:
        df_addr.to_excel(writer, sheet_name="Address Comparison", index=False)
        df_codes.to_excel(writer, sheet_name="Code Comparison", index=False)
        df_items.to_excel(writer, sheet_name="WO Items", index=False)
        df_match.to_excel(writer, sheet_name="Matched Quantities", index=False)
        df_mismatch.to_excel(writer, sheet_name="Mismatched Quantities", index=False)
        
        # Add PO Details sheet if data exists
        if po_details:
            df_po_details = pd.DataFrame(po_details)
            df_po_details.to_excel(writer, sheet_name="PO Details", index=False)
    
    buf.seek(0)
    return buf

# Streamlit UI
st.set_page_config(page_title="WO ‚Üî PO Compare", layout="centered")
st.title("üìÑ WO vs PO Comparator")

# Add option to choose matching method
matching_method = st.selectbox(
    "Choose Quantity Matching Method:",
    ["Smart Matching (Exact)", "Smart Matching with Tolerance", "Original Order-based"]
)

if matching_method == "Smart Matching with Tolerance":
    tolerance = st.number_input("Tolerance (acceptable difference)", min_value=0, max_value=100, value=5)

wo_file = st.file_uploader("Upload WO PDF", type="pdf")
po_file = st.file_uploader("Upload PO PDF", type="pdf")

if wo_file and po_file:
    st.success("Processing...")
    wo = extract_wo_fields(wo_file)
    po = extract_po_fields(po_file)
    wo_items = extract_wo_items(wo_file)
    po_qtys = extract_po_quantities(po_file)
    
    # Extract PO details with color codes and sizes
    po_details = extract_po_details(po_file)
    
    addr_res = compare_addresses(wo, po)
    code_res = compare_codes(wo["product_codes"], po["product_codes"])
    
    # Choose matching method based on user selection
    if matching_method == "Smart Matching (Exact)":
        matched, mismatched = smart_quantity_matching(wo_items, po_qtys)
    elif matching_method == "Smart Matching with Tolerance":
        matched, mismatched = smart_quantity_matching_with_tolerance(wo_items, po_qtys, tolerance)
    else:
        # Original order-based matching for comparison
        matched_orig = []
        mismatched_orig = []
        for i, item in enumerate(wo_items):
            wo_qty = item["Quantity"]
            po_qty = po_qtys[i] if i < len(po_qtys) else None
            diff = po_qty - wo_qty if po_qty is not None else ""
            status = "‚úÖ Match" if po_qty == wo_qty else "‚ö†Ô∏è Mismatch"
            result = {
                "Style": item["Style"],
                "Size 1": item["Size 1"],
                "Colour Code": item.get("Colour Code", ""),
                "WO Qty": wo_qty,
                "PO Qty": po_qty,
                "Diff": diff,
                "Status": status
            }
            if status == "‚úÖ Match":
                matched_orig.append(result)
            else:
                mismatched_orig.append(result)
        matched, mismatched = matched_orig, mismatched_orig

    st.subheader("üè∑ Address Comparison")
    st.dataframe(pd.DataFrame([addr_res]))

    st.subheader("üÜö Product Code Matching")
    st.dataframe(pd.DataFrame(code_res))

    st.subheader("üëï Extracted WO Item Details")
    st.dataframe(pd.DataFrame(wo_items))

    # Display PO Details
    st.subheader("üìã PO Details (Color Codes & Sizes)")
    if po_details:
        st.dataframe(pd.DataFrame(po_details))
    else:
        st.info("No PO details extracted.")

    st.subheader("‚úÖ Matched Quantities")
    if matched:
        st.dataframe(pd.DataFrame(matched))
    else:
        st.info("No matched quantities found.")

    st.subheader("‚ö†Ô∏è Mismatched Quantities")
    if mismatched:
        st.dataframe(pd.DataFrame(mismatched))
    else:
        st.info("No mismatched quantities found.")

    # Summary statistics
    col1, col2, col3, col4 = st.columns(4)
    with col1:
        st.metric("Total WO Items", len(wo_items))
    with col2:
        st.metric("Total PO Items", len(po_details))
    with col3:
        st.metric("Matched", len(matched))
    with col4:
        st.metric("Mismatched", len(mismatched))

    excel_buf = make_excel(addr_res, code_res, wo_items, matched, mismatched, po_details)
    st.download_button("üì• Download Results", data=excel_buf, file_name="comparison.xlsx")